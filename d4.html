<!DOCTYPE html>
 <html lang="en">
 <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
     <title>D4 Realista com Física 2D</title>

     <style>
         body {
             display: flex;
             flex-direction: column;
             justify-content: flex-end;
             align-items: center;
             height: 100vh;
             margin: 0;
             background: radial-gradient(circle at center, #3a3a3a, #1a1a1a);
             font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
             overflow: hidden;
             user-select: none;
         }

         #dice-container {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             overflow: hidden;
         }

         .controls {
             position: fixed;
             bottom: 0;
             left: 0;
             width: 100%;
             padding: 20px;
             box-sizing: border-box;
             display: flex;
             flex-direction: column;
             align-items: center;
             background: linear-gradient(to top, rgba(26, 26, 26, 0.8), transparent);
             z-index: 10;
         }

         #roll-button {
             padding: 12px 25px;
             font-size: 1.1rem;
             font-weight: bold;
             cursor: pointer;
             background: linear-gradient(145deg, #5a5a5a, #3a3a3a);
             border: none;
             border-radius: 8px;
             color: #e0e0e0;
             text-shadow: 0px 1px 2px rgba(0,0,0,0.5);
             box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5),
                         inset 0px 1px 1px rgba(255,255,255,0.2);
             transition: transform 0.15s ease;
         }

         #result-display {
             margin-top: 15px;
             font-size: 1.5rem;
             color: #fff;
             min-height: 2rem;
             font-weight: bold;
             text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
         }
     </style>
 </head>
 <body>
     <div id="dice-container"></div>
     <div class="controls">
         <button id="roll-button">Rolar Dado</button>
         <div id="result-display">Pressione o botão para rolar</div>
     </div>

     <script type="importmap">
 {
   "imports": {
     "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
     "three/examples/jsm/loaders/FontLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/FontLoader.js",
     "three/examples/jsm/geometries/TextGeometry.js": "https://unpkg.com/three@0.160.0/examples/jsm/geometries/TextGeometry.js"
   }
 }
 </script>


     <script type="module">
         import * as THREE from 'three';
         import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
         import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';



 // Configurações de física ajustadas para comportamento de tetraedro
 // Mantidos os valores originais do seu código
 const FRICTION = 0.95;
 const WALL_BOUNCE_DAMPENING = 0.8;
 const MIN_VELOCITY = 0.02; // Limite original para parar (agora usado para INICIAR alinhamento)
 const MAX_VELOCITY = 5;
 const INITIAL_FORCE_MULTIPLIER = 2;
 const COLLISION_COOLDOWN = 150;
 const ROTATION_SPEED = 1.5;
 const BOUNCE_HEIGHT_MULTIPLIER = 2.0;
 const INITIAL_BOUNCE_COUNT = 4;
 const TUMBLE_FACTOR = 0.6;
 const VERTEX_IMPACT_CHANCE = 0.7;

 // Variáveis para o alinhamento SUTIL
 let targetQuaternion = null;
 let aligning = false;
 const ALIGNMENT_START_VELOCITY = MIN_VELOCITY * 3; // Começa o alinhamento um pouco antes
 const ALIGNMENT_SPEED = 0.02; // Velocidade BEM lenta da interpolação (Slerp)
 const ALIGNMENT_THRESHOLD = 0.001; // Limiar para considerar o alinhamento completo (mais preciso)


 // Configurações de escala para visual mais realista (não usadas no momento, podem ser removidas)
 const SCALE = {
     MIN: 0.8,
     MAX: 1.5,
     FLIGHT: 1.2,
     BOUNCE: 1.1
 };

 // Setup Three.js (mantido como estava)
 const scene = new THREE.Scene();
 scene.background = new THREE.Color('#3a3a3a');
 const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setSize(window.innerWidth, window.innerHeight);
 document.getElementById('dice-container').appendChild(renderer.domElement);

 // Configurar câmera para visão top-down (ajustada)
 camera.position.set(0, 10, 0); // Posição Y mais alta
 camera.lookAt(0, 0, 0); // Olha para o centro da cena
 // Removemos camera.rotation.z = Math.PI; pois lookAt já orienta

 // Criar tetraedro com material mais realista
 const geometry = new THREE.TetrahedronGeometry(1);
 const material = new THREE.MeshPhongMaterial({
     color: 0x1a237e,
     shininess: 70,
     specular: 0x333333,
     flatShading: true
 });
 const dice = new THREE.Mesh(geometry, material);
 scene.add(dice);

 // Carregar fonte padrão do Three.js
 const loader = new FontLoader();
 loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
     const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });

     const numberPositions = [
         // Posições originais mantidas
         { pos: new THREE.Vector3(-0.4, 0.2, -0.2), rot: new THREE.Euler(-0.5, -0.5, 0), text: '1' },
         { pos: new THREE.Vector3(-0.2, 0.2, 0.4), rot: new THREE.Euler(-0.5, -0.5, 0), text: '1' },
         { pos: new THREE.Vector3(-0.4, -0.2, 0.2), rot: new THREE.Euler(0.5, -0.5, 0), text: '1' },

         { pos: new THREE.Vector3(0.4, 0.2, -0.2), rot: new THREE.Euler(-0.5, 0.5, 0), text: '2' },
         { pos: new THREE.Vector3(0.2, 0.2, 0.4), rot: new THREE.Euler(-0.5, 0.5, 0), text: '2' },
         { pos: new THREE.Vector3(0.4, -0.2, 0.2), rot: new THREE.Euler(0.5, 0.5, 0), text: '2' },

         { pos: new THREE.Vector3(0, -0.4, -0.2), rot: new THREE.Euler(0.5, 0, 0), text: '3' },
         { pos: new THREE.Vector3(-0.2, -0.4, 0.2), rot: new THREE.Euler(0.5, -0.5, 0), text: '3' },
         { pos: new THREE.Vector3(0.2, -0.4, 0.2), rot: new THREE.Euler(0.5, 0.5, 0), text: '3' },

         { pos: new THREE.Vector3(0, 0.4, 0.2), rot: new THREE.Euler(-0.5, 0, 0), text: '4' },
         { pos: new THREE.Vector3(-0.2, 0.3, 0.3), rot: new THREE.Euler(-0.5, -0.5, 0), text: '4' },
         { pos: new THREE.Vector3(0.2, 0.3, 0.3), rot: new THREE.Euler(-0.5, 0.5, 0), text: '4' }
     ];

     numberPositions.forEach(({ pos, rot, text }) => {
         const textGeo = new TextGeometry(text, {
             font: font,
             size: 0.2,
             height: 0.01,
             curveSegments: 12,
             bevelEnabled: false
         });

         textGeo.computeBoundingBox();
         const centerOffset = new THREE.Vector3(
             -(textGeo.boundingBox.max.x - textGeo.boundingBox.min.x) / 2,
             -(textGeo.boundingBox.max.y - textGeo.boundingBox.min.y) / 2,
             -(textGeo.boundingBox.max.z - textGeo.boundingBox.min.z) / 2
         );

         const textMesh = new THREE.Mesh(textGeo, textMaterial);
         textMesh.position.copy(pos).add(centerOffset);
         textMesh.rotation.copy(rot);

         dice.add(textMesh);
     });
 });


 // Iluminação ajustada
 const light = new THREE.DirectionalLight(0xffffff, 1.2);
 light.position.set(5, 8, 5);
 scene.add(light);
 scene.add(new THREE.AmbientLight(0x404040, 0.8));

 // Estado do dado
 let isRolling = false;
 let pressStartTime = 0;
 let velocity = new THREE.Vector2();
 let angularVelocity = new THREE.Vector3();
 let phase = 'ready';
 let flightTime = 0;
 let bounceCount = INITIAL_BOUNCE_COUNT;
 let lastCollisionTime = 0;
 let lastVertexImpact = 0;

 // Função para simular impacto no vértice (mantida)
 function handleVertexImpact() {
     const currentTime = Date.now();
     if (currentTime - lastVertexImpact < 200) return false;

     if (Math.random() < VERTEX_IMPACT_CHANCE) {
         lastVertexImpact = currentTime;
          angularVelocity.set(
             random(-0.5, 0.5) * ROTATION_SPEED,
             random(-0.5, 0.5) * ROTATION_SPEED,
             random(-0.5, 0.5) * ROTATION_SPEED
         );
         return true;
     }
     return false;
 }

 function random(min, max) {
     return Math.random() * (max - min) + min;
 }

 // Função para determinar qual vértice está mais alto (resultando no número correspondente)
 function getTopVertexResult() {
    const positions = geometry.getAttribute('position');
    const matrix = dice.matrixWorld;

    let topVertexIndex = 0;
    let highestY = -Infinity;

    // Itera sobre todos os vértices da geometria
    for (let i = 0; i < positions.count; i++) {
        const vertex = new THREE.Vector3().fromBufferAttribute(positions, i);
        vertex.applyMatrix4(matrix); // Transforma para espaço do mundo

        if (vertex.y > highestY) {
            highestY = vertex.y;
            topVertexIndex = i;
        }
    }

    // Mapeamento do índice do vértice para o resultado do dado (1 a 4)
    // Índice 0 -> Resultado 1, Índice 1 -> Resultado 2, etc. (assumindo a orientação da geometria)
     return topVertexIndex + 1; // Retorna o número do dado (1 a 4)
 }

 // Funções antigas getTargetQuaternionForVertex e getTopFace removidas, pois não usaremos mais a abordagem anterior.


 // Função de animação ajustada
 function animate() {
     requestAnimationFrame(animate);

     // Só atualiza a física se estiver rolando ou alinhando
     if (!isRolling && !aligning) {
          renderer.render(scene, camera);
          return;
     }

     const deltaTime = 1 / 60; // Assume 60fps

     switch (phase) {
         case 'throwing':
             dice.position.x += velocity.x * deltaTime;
             dice.position.z += velocity.y * deltaTime;

             flightTime += deltaTime;
             const height = Math.sin(flightTime * Math.PI) * BOUNCE_HEIGHT_MULTIPLIER;
             dice.position.y = Math.max(0, height * 2);

             dice.rotation.x += angularVelocity.x * deltaTime * (1 + random(-0.2, 0.2));
             dice.rotation.y += angularVelocity.y * deltaTime * (1 + random(-0.2, 0.2));
             dice.rotation.z += angularVelocity.z * deltaTime * (1 + random(-0.2, 0.2));

             if (flightTime >= 1) {
                 phase = 'bouncing';
                 bounceCount = INITIAL_BOUNCE_COUNT;
                 flightTime = 0;
                 // handleVertexImpact(); // Pode simular impacto aqui se desejar
             }
             break;

         case 'bouncing':
             dice.position.x += velocity.x * deltaTime * 0.5;
             dice.position.z += velocity.y * deltaTime * 0.5;
             velocity.multiplyScalar(Math.pow(FRICTION, deltaTime * 60));

             flightTime += deltaTime;
             const bounceHeight = Math.sin(flightTime * Math.PI) *
                                  (BOUNCE_HEIGHT_MULTIPLIER / (bounceCount + 1)) *
                                  Math.max(velocity.length(), 0.1);

             dice.position.y = Math.max(0, bounceHeight + random(-0.02, 0.02));

             angularVelocity.multiplyScalar(Math.pow(FRICTION, deltaTime * 60));
             dice.rotation.x += angularVelocity.x * deltaTime * 0.7;
             dice.rotation.y += angularVelocity.y * deltaTime * 0.7;
             dice.rotation.z += angularVelocity.z * deltaTime * 0.7;

             // Colisão com as paredes (ajustada para framerate)
             if (dice.position.x <= -5 || dice.position.x >= 5) {
                 dice.position.x = dice.position.x <= -5 ? -5 : 5;
                 velocity.x *= -WALL_BOUNCE_DAMPENING;
                 handleVertexImpact(); // Adiciona rotação no impacto
             }

             if (dice.position.z <= -5 || dice.position.z >= 5) {
                 dice.position.z = dice.position.z <= -5 ? -5 : 5;
                 velocity.y *= -WALL_BOUNCE_DAMPENING;
                 handleVertexImpact(); // Adiciona rotação no impacto
             }

             if (flightTime >= 1) {
                 bounceCount--;
                 flightTime = 0;

                 // Transiciona para rolling mais cedo se a velocidade for baixa
                 if (bounceCount <= 0 || velocity.length() < ALIGNMENT_START_VELOCITY) {
                      phase = 'rolling';
                     // Mantém um pouco de velocidade e rotação para a fase rolling
                     velocity.multiplyScalar(0.5);
                     angularVelocity.multiplyScalar(0.5);
                 } else {
                      velocity.x += random(-0.1, 0.1) * TUMBLE_FACTOR * 0.5;
                      velocity.y += random(-0.1, 0.1) * TUMBLE_FACTOR * 0.5;
                      handleVertexImpact();
                 }
             }
             break;

         case 'rolling':
             // Continua a desaceleração
             dice.position.x += velocity.x * deltaTime * 0.3;
             dice.position.z += velocity.y * deltaTime * 0.3;

             velocity.multiplyScalar(Math.pow(FRICTION * 0.9, deltaTime * 60));
             angularVelocity.multiplyScalar(Math.pow(FRICTION * 0.9, deltaTime * 60));

             dice.position.y = 0.01; // Mantém no chão

             // === Lógica de Alinhamento Sutil ===
             // Inicia o alinhamento quando a velocidade atinge o limite de início
             if (velocity.length() < ALIGNMENT_START_VELOCITY && angularVelocity.length() < ALIGNMENT_START_VELOCITY && !aligning) {
                 aligning = true;
                 const result = getTopVertexResult(); // Encontra o resultado ANTES de alinhar
                 resultDisplay.textContent = `Resultado: ${result}`;

                 // --- Calcula o Quaternion de Alvo ---
                 const topVertexIndex = result - 1;
                 const vertexLocal = new THREE.Vector3().fromBufferAttribute(geometry.getAttribute('position'), topVertexIndex);
                 const vertexWorld = vertexLocal.clone().applyMatrix4(dice.matrixWorld);
                 const currentVertexDirectionWorld = vertexWorld.sub(dice.position).normalize();
                 const targetUpWorld = new THREE.Vector3(0, 1, 0);
                 const rotationToAlign = new THREE.Quaternion().setFromUnitVectors(currentVertexDirectionWorld, targetUpWorld);
                 targetQuaternion = new THREE.Quaternion().copy(dice.quaternion).multiply(rotationToAlign);

                  // Reduz drasticamente as velocidades ao iniciar o alinhamento
                  velocity.multiplyScalar(0.1);
                  angularVelocity.multiplyScalar(0.1);
             }

             // Se estiver alinhando, aplica a rotação suave
             if (aligning && targetQuaternion) {
                 // Interpolação esférica (Slerp) BEM suave
                 dice.quaternion.slerp(targetQuaternion, ALIGNMENT_SPEED);

                 // Continua aplicando um mínimo de física durante o alinhamento para parecer mais natural
                 dice.rotation.x += angularVelocity.x * deltaTime * 0.1;
                 dice.rotation.y += angularVelocity.y * deltaTime * 0.1;
                 dice.rotation.z += angularVelocity.z * deltaTime * 0.1;

                 // Verifica se a rotação está muito próxima do alvo para parar
                 if (dice.quaternion.angleTo(targetQuaternion) < ALIGNMENT_THRESHOLD) {
                     // Alinhamento completo
                     dice.quaternion.copy(targetQuaternion); // Define a rotação final exatamente
                     aligning = false;
                     isRolling = false;
                     phase = 'ready';
                     rollButton.disabled = false; // Libera o botão

                     // Zera velocidades finais
                     velocity.set(0, 0);
                     angularVelocity.set(0, 0, 0);
                 }
             } else {
                 // Se NÃO está alinhando, mas está na fase 'rolling', aplica a rotação remanescente normal
                  const deltaRotation = new THREE.Euler(
                     angularVelocity.x * deltaTime * 0.5,
                     angularVelocity.y * deltaTime * 0.5,
                     angularVelocity.z * deltaTime * 0.5
                 );
                 dice.rotation.x += deltaRotation.x;
                 dice.rotation.y += deltaRotation.y;
                 dice.rotation.z += deltaRotation.z;

                 // Se a velocidade caiu abaixo do limite mínimo e NÃO está alinhando
                 // (isso só deve acontecer se ALIGNMENT_START_VELOCITY for maior que MIN_VELOCITY,
                 // mas é uma garantia para parar completamente)
                 if (velocity.length() < MIN_VELOCITY && angularVelocity.length() < 0.005) {
                     isRolling = false;
                     phase = 'ready';
                     rollButton.disabled = false;
                     velocity.set(0, 0);
                     angularVelocity.set(0, 0, 0);
                      const result = getTopVertexResult(); // Pega o resultado final
                     resultDisplay.textContent = `Resultado: ${result}`;
                 }

             } // Fim da lógica de alinhamento/rolagem

             break; // Fim do case 'rolling'
     } // Fim do switch(phase)


     renderer.render(scene, camera);
 } // Fim da função animate


 // Event Listeners para o botão com lançamento ajustado
 const rollButton = document.getElementById('roll-button');
 const resultDisplay = document.getElementById('result-display');

 function setInitialDicePosition() {
     dice.position.set(
         0,
         0,
         -5.5
     );
      dice.rotation.set(0, 0, 0); // Reseta rotação
      dice.quaternion.identity(); // Reseta quaternion
 }

 // Chamada fora da função
 // setInitialDicePosition(); // Será chamada dentro do animate inicial


 rollButton.addEventListener("mousedown", () => {
     if (isRolling || aligning) return;
     pressStartTime = Date.now();
     rollButton.style.transform = 'scale(0.95)';
 });

 rollButton.addEventListener("mouseup", () => {
     if (isRolling || aligning) return;

     const pressDuration = Math.min(Date.now() - pressStartTime, 4000);
     const forceFactor = pressDuration / 4000;

     isRolling = true;
     aligning = false; // Garante que não está alinhando
     targetQuaternion = null; // Limpa o quaternion alvo
     rollButton.disabled = true;
     resultDisplay.textContent = "Rolando...";
     phase = 'throwing';

     const force = INITIAL_FORCE_MULTIPLIER * (0.2 + forceFactor * 0.2);

     dice.position.set(0, 0, -5.5); // Define a posição inicial novamente

     velocity.set(
         random(-0.5, 0.5), // Variação lateral inicial um pouco maior
         force * 2 // Força no eixo Z (para "cima" na tela)
     );

     angularVelocity.set(
         random(-1, 1) * ROTATION_SPEED,
         random(-1, 1) * ROTATION_SPEED,
         random(-1, 1) * ROTATION_SPEED
     );


     flightTime = 0;
     bounceCount = INITIAL_BOUNCE_COUNT;

     console.log(`[${new Date().toISOString()}] User rolled the dice`);
     // requestAnimationFrame(animate); // Já chamado no final
     rollButton.style.transform = '';
 });

 // Ajuste de redimensionamento
 window.addEventListener('resize', () => {
     camera.aspect = window.innerWidth / window.innerHeight;
     camera.updateProjectionMatrix();
     renderer.setSize(window.innerWidth, window.innerHeight);
     // setInitialDicePosition(); // Não redefinir a posição durante o redimensionamento se o dado estiver rolando
 });

 // Iniciar a animação e definir a posição inicial na primeira renderização
 setInitialDicePosition(); // Define a posição inicial
 animate(); // Inicia o loop de animação

 console.log(`[${new Date().toISOString()}] D4 initialized`);
     </script>


 </body>
 </html>
