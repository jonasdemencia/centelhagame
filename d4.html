<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>D4 Realista com Física 3D (Cannon-es)</title>

    <style>
        /* Estilos CSS mantidos como antes */
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: radial-gradient(circle at center, #3a3a3a, #1a1a1a);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #dice-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(to top, rgba(26, 26, 26, 0.8), transparent);
            z-index: 10;
        }

        #roll-button {
            padding: 12px 25px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            background: linear-gradient(145deg, #5a5a5a, #3a3a3a);
            border: none;
            border-radius: 8px;
            color: #e0e0e0;
            text-shadow: 0px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5),
                        inset 0px 1px 1px rgba(255,255,255,0.2);
            transition: transform 0.15s ease;
        }

        #result-display {
            margin-top: 15px;
            font-size: 1.5rem;
            color: #fff;
            min-height: 2rem;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="dice-container"></div>
    <div class="controls">
        <button id="roll-button">Rolar Dado</button>
        <div id="result-display">Pressione o botão para rolar</div>
    </div>

    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
    "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
  }
}
</script>


    <script type="module">
    import * as THREE from 'three';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
    import * as CANNON from 'cannon-es';

        // --- Configurações Globais ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#3a3a3a');
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('dice-container').appendChild(renderer.domElement);

        camera.position.set(0, 7, 0); // Câmera um pouco mais baixa para ver melhor
        camera.lookAt(0, 0, 0);
        // camera.rotation.z = Math.PI; // Não mais necessário com lookAt

        // Iluminação
        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(5, 8, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xcccccc, 0.8)); // Luz ambiente mais clara

        // --- Setup da Física (Cannon-es) ---
        const world = new CANNON.World({
            gravity: new CANNON.Vec3(0, -9.82 * 2, 0) // Gravidade um pouco mais forte talvez? Ajuste!
        });
        world.allowSleep = true; // Permitir que os corpos durmam (essencial para detectar parada)
        world.broadphase = new CANNON.SAPBroadphase(world); // Otimização

        // Materiais Físicos
        const groundMaterial = new CANNON.Material('ground');
        const diceMaterial = new CANNON.Material('dice');

        const groundDiceContact = new CANNON.ContactMaterial(groundMaterial, diceMaterial, {
            friction: 0.2,      // Atrito entre dado e chão (ajuste conforme necessário)
            restitution: 0.4    // Elasticidade/Bounciness (0=morto, 1=super elástico)
        });
        world.addContactMaterial(groundDiceContact);

        // Corpo do Chão
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({
            mass: 0, // Estático
            shape: groundShape,
            material: groundMaterial
        });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Deixa o plano horizontal
        groundBody.position.set(0, -0.1, 0); // Um pouco abaixo da origem visual
        world.addBody(groundBody);

        // --- Criação do Dado (Three.js) ---
        const geometry = new THREE.TetrahedronGeometry(1); // Tamanho 1
        const material = new THREE.MeshPhongMaterial({
            color: 0x1a237e, // Azul escuro
            shininess: 80,
            specular: 0xaaaaaa,
            flatShading: false // Shading suave fica melhor com Phong
        });
        const dice = new THREE.Mesh(geometry, material);
        scene.add(dice);

        // --- Criação do Corpo Físico do Dado (Cannon-es) ---
        // Extrair vértices e faces da geometria do Three.js
        const vertices = geometry.attributes.position.array;
        const cannonVertices = [];
        for (let i = 0; i < vertices.length; i += 3) {
            cannonVertices.push(new CANNON.Vec3(vertices[i], vertices[i + 1], vertices[i + 2]));
        }

        
       // --- Criação do Corpo Físico do Dado (Cannon-es) ---
const positionAttribute = geometry.attributes.position;
const vertexArray = positionAttribute.array;
const cannonVertices = [];

// Converter vértices do Three.js para Cannon.js
for (let i = 0; i < vertexArray.length; i += 3) {
    cannonVertices.push(new CANNON.Vec3(
        vertexArray[i],
        vertexArray[i + 1],
        vertexArray[i + 2]
    ));
}

// Definir faces do tetraedro manualmente
const cannonFaces = [
    [0, 1, 2],  // Face 0
    [0, 2, 3],  // Face 1
    [0, 3, 1],  // Face 2
    [1, 3, 2]   // Face 3
];

// Criar forma e corpo físico
const diceShape = new CANNON.ConvexPolyhedron({
    vertices: cannonVertices,
    faces: cannonFaces
});

const diceBody = new CANNON.Body({
    mass: 1.5,
    shape: diceShape,
    material: diceMaterial,
    angularDamping: 0.4,
    linearDamping: 0.2,
    allowSleep: true,
    sleepSpeedLimit: 0.1,
    sleepTimeLimit: 0.1
});

diceBody.position.set(0, 5, 0);
world.addBody(diceBody);

        const diceShape = new CANNON.ConvexPolyhedron({ vertices: cannonVertices, faces: cannonFaces });
        const diceBody = new CANNON.Body({
            mass: 1.5, // Massa do dado (afeta impulsos)
            shape: diceShape,
            material: diceMaterial,
            angularDamping: 0.4, // Amortecimento rotacional (ajuda a parar de girar)
            linearDamping: 0.2   // Amortecimento linear (ajuda a parar de deslizar)
        });
        diceBody.position.set(0, 5, 0); // Posição inicial (acima do chão)
        world.addBody(diceBody);

        // Carregar Fonte e Adicionar Números (igual antes, mas adicionados ao 'dice' mesh)
        const loader = new FontLoader();
        loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
             const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
             // Ajuste fino das posições/rotações pode ser necessário para alinhar com os vértices corretos
            const numberPositions = [
                 // Vértice 0 (oposto face 1,2,3) -> Resultado 1
                 { pos: new THREE.Vector3(0.35, 0.35, 0.35), rot: new THREE.Euler(-Math.PI/4, Math.PI/4, 0), text: '1' }, // Ajustar pos/rot
                 { pos: new THREE.Vector3(0.35, 0.35, 0.35), rot: new THREE.Euler(-Math.PI/4, Math.PI/4, 0), text: '1' }, // Duplicado - Precisa de 3 posições diferentes ao redor do vértice
                 { pos: new THREE.Vector3(0.35, 0.35, 0.35), rot: new THREE.Euler(-Math.PI/4, Math.PI/4, 0), text: '1' }, // Triplicado

                 // Vértice 1 (oposto face 0,2,3) -> Resultado 2
                 // ... posições e rotações para '2' ao redor do vértice 1 ...
                 { pos: new THREE.Vector3(-0.35, -0.35, 0.35), rot: new THREE.Euler(Math.PI*3/4, Math.PI/4, 0), text: '2' }, // Exemplo
                 // ... mais duas posições para '2' ...

                 // Vértice 2 (oposto face 0,1,3) -> Resultado 3
                 // ... posições e rotações para '3' ao redor do vértice 2 ...
                 { pos: new THREE.Vector3(-0.35, 0.35, -0.35), rot: new THREE.Euler(-Math.PI/4, -Math.PI/4, 0), text: '3' }, // Exemplo
                 // ... mais duas posições para '3' ...

                 // Vértice 3 (oposto face 0,1,2) -> Resultado 4
                 // ... posições e rotações para '4' ao redor do vértice 3 ...
                 { pos: new THREE.Vector3(0.35, -0.35, -0.35), rot: new THREE.Euler(Math.PI*3/4, -Math.PI/4, 0), text: '4' }, // Exemplo
                 // ... mais duas posições para '4' ...
             ];
             // TODO: Definir corretamente as 3 posições/rotações para CADA número ao redor do seu vértice correspondente.
             // O código original tinha posições que pareciam mais aleatórias do que agrupadas por vértice.

            numberPositions.forEach(({ pos, rot, text }) => {
                const textGeo = new TextGeometry(text, {
                    font: font, size: 0.2, height: 0.01, curveSegments: 6, bevelEnabled: false
                });
                textGeo.computeBoundingBox();
                const centerOffset = new THREE.Vector3(
                    -(textGeo.boundingBox.max.x - textGeo.boundingBox.min.x) / 2,
                    -(textGeo.boundingBox.max.y - textGeo.boundingBox.min.y) / 2,
                    -(textGeo.boundingBox.max.z - textGeo.boundingBox.min.z) / 2
                );
                const textMesh = new THREE.Mesh(textGeo, textMaterial);
                // Calcular posição relativa à face/vértice
                // textMesh.position.copy(pos).add(centerOffset); // Usar posições corretas
                // textMesh.rotation.copy(rot); // Usar rotações corretas
                 // Precisa de uma lógica melhor para posicionar os 3 números em cada face que converge no vértice
                 // Exemplo temporário fixo (apenas para ver algo):
                 if (text === '1') textMesh.position.set(0.3, 0.3, 0.3).add(centerOffset);
                 if (text === '2') textMesh.position.set(-0.3, -0.3, 0.3).add(centerOffset);
                 if (text === '3') textMesh.position.set(-0.3, 0.3, -0.3).add(centerOffset);
                 if (text === '4') textMesh.position.set(0.3, -0.3, -0.3).add(centerOffset);

                dice.add(textMesh); // Adiciona o texto como filho do mesh do dado
            });
        });


        // --- Estado e Controles ---
        let isRolling = false;
        const rollButton = document.getElementById('roll-button');
        const resultDisplay = document.getElementById('result-display');

        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        // Função para obter resultado (lê orientação do MESH Three.js)
        function getResultFromTopVertex() {
            // Vértices locais da THREE.TetrahedronGeometry(1)
            // Importante: A ordem aqui DEVE corresponder ao resultado desejado
            const vertices = [
                 // Ordem baseada na documentação/experimento com THREE.TetrahedronGeometry:
                 new THREE.Vector3(1, 1, 1),    // Vértice 0 (resultado esperado: 1 ? verificar!)
                 new THREE.Vector3(-1, -1, 1),  // Vértice 1 (resultado esperado: 2 ?)
                 new THREE.Vector3(-1, 1, -1),  // Vértice 2 (resultado esperado: 3 ?)
                 new THREE.Vector3(1, -1, -1)   // Vértice 3 (resultado esperado: 4 ?)
            ];

             // Precisamos normalizar para que a escala não afete qual é o "mais alto" relativo à orientação
             // Mas a função original não normalizava. Vamos manter assim por enquanto.
             // A matriz world já contém a escala, rotação e posição.

             const worldVertices = vertices.map(v => v.clone().applyMatrix4(dice.matrixWorld));

             let highestVertexIndex = -1;
             let maxY = -Infinity;

             for (let i = 0; i < worldVertices.length; i++) {
                 if (worldVertices[i].y > maxY) {
                     maxY = worldVertices[i].y;
                     highestVertexIndex = i;
                 }
             }

             // Mapeia o índice do vértice mais alto para o resultado (1 a 4)
             // CONFIRME ESTE MAPEAMENTO! Pode precisar ajustar (ex: talvez seja [3, 4, 1, 2] dependendo da geometria)
             const vertexIndexToResultMap = [1, 2, 3, 4]; // Suposição inicial, VERIFICAR!
             return vertexIndexToResultMap[highestVertexIndex] || 'Erro'; // Retorna o resultado mapeado
        }


        // --- Lógica de Rolagem (Physics Based) ---
        rollButton.addEventListener("mousedown", () => {
            if (isRolling) return;
             rollButton.style.transform = 'scale(0.95)';
        });

        rollButton.addEventListener("mouseup", () => {
            if (isRolling) return;

            isRolling = true;
            rollButton.disabled = true;
            resultDisplay.textContent = "Rolando...";
            rollButton.style.transform = '';


            // Acorda o corpo físico
            diceBody.wakeUp();

            // Posição inicial aleatória acima do chão
            const startX = random(-1.5, 1.5);
            const startZ = random(-1.5, 1.5);
            diceBody.position.set(startX, 5, startZ); // Começa alto para cair
            diceBody.quaternion.setFromEuler(
                random(0, Math.PI * 2),
                random(0, Math.PI * 2),
                random(0, Math.PI * 2)
            );

            // Zera velocidades anteriores
            diceBody.velocity.set(0, 0, 0);
            diceBody.angularVelocity.set(0, 0, 0);

            // Aplica Impulso (força linear) - Ajuste a magnitude!
            const impulseMagnitude = 7 + random(0, 3); // 7 a 10
            const impulseDirection = new CANNON.Vec3(random(-1, 1), 0.5, random(-1, 1)).normalize(); // Um pouco para cima e lateralmente
            diceBody.applyImpulse(impulseDirection.scale(impulseMagnitude), new CANNON.Vec3(0,0,0)); // Impulso no centro

            // Aplica Torque (força rotacional) - Ajuste a magnitude!
            const torqueMagnitude = 8 + random(0, 4); // 8 a 12
            const torqueAxis = new CANNON.Vec3(random(-1, 1), random(-1, 1), random(-1, 1)).normalize();
            diceBody.applyTorque(torqueAxis.scale(torqueMagnitude));

            console.log(`[${new Date().toISOString()}] Dice Roll Triggered (Physics)`);
        });

        // --- Evento de Repouso (Sleep) ---
        diceBody.addEventListener('sleep', () => {
            console.log("Dice physics body has fallen asleep.");
            // Só processa o resultado se estava rolando (evita processar no início)
            if (isRolling) {
                isRolling = false;
                rollButton.disabled = false;

                // Garante que as velocidades estão zeradas no corpo físico
                diceBody.velocity.set(0, 0, 0);
                diceBody.angularVelocity.set(0, 0, 0);

                // Sincroniza a posição final exata (caso o último step não tenha sido renderizado)
                dice.position.copy(diceBody.position);
                dice.quaternion.copy(diceBody.quaternion);

                // Garante visualmente que está no chão (pode precisar ajustar baseado no raio/altura real)
                 const approxRadius = 0.5; // Raio aproximado da esfera inscrita no tetraedro de tamanho 1
                 if (dice.position.y < approxRadius) {
                    // dice.position.y = approxRadius; // Comentado - O motor deve cuidar disso com o chão
                 }


                // Determina o resultado pela orientação do mesh
                const result = getResultFromTopVertex();
                resultDisplay.textContent = `Resultado: ${result}`;
                console.log(`[${new Date().toISOString()}] Result Determined (Physics Sleep): ${result}`);
            }
        });

        // --- Loop de Animação ---
        const clock = new THREE.Clock();
        let lastTime = 0;

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() / 1000;
            const deltaTime = time - lastTime;
            lastTime = time;

            // Só avança a física se houver deltaTime (evita NaN na primeira vez)
            // E só precisa avançar se o dado estiver potencialmente se movendo
            // if (deltaTime > 0 && !diceBody.sleepState === CANNON.Body.SLEEPING) { // Poderia otimizar assim? Testar.
            if (deltaTime > 0) { // Avança sempre por enquanto
                 // world.step(1 / 60, deltaTime); // Timestep fixo é mais estável
                 // Usar timestep variável pode ser mais simples aqui:
                  world.step(deltaTime);
            }

            // Sincroniza o mesh Three.js com o corpo Cannon.js
            dice.position.copy(diceBody.position);
            dice.quaternion.copy(diceBody.quaternion);

             // Pequeno ajuste visual para garantir que não afunde (opcional, física deve cuidar)
            // if (dice.position.y < 0) dice.position.y = 0;


            renderer.render(scene, camera);
        }

        // --- Inicialização ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Sincroniza a posição inicial do mesh (opcional, pois será sobrescrito no primeiro frame)
        dice.position.copy(diceBody.position);
        dice.quaternion.copy(diceBody.quaternion);

        animate(); // Inicia o loop
        console.log(`[${new Date().toISOString()}] D4 Initialized with Cannon-es`);

    </script>
</body>
</html>
