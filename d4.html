<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>D4 Realista com Física 2D</title>

    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: radial-gradient(circle at center, #3a3a3a, #1a1a1a);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #dice-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(to top, rgba(26, 26, 26, 0.8), transparent);
            z-index: 10;
        }

        #roll-button {
            padding: 12px 25px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            background: linear-gradient(145deg, #5a5a5a, #3a3a3a);
            border: none;
            border-radius: 8px;
            color: #e0e0e0;
            text-shadow: 0px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5),
                        inset 0px 1px 1px rgba(255,255,255,0.2);
            transition: transform 0.15s ease;
        }

        #result-display {
            margin-top: 15px;
            font-size: 1.5rem;
            color: #fff;
            min-height: 2rem;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="dice-container"></div>
    <div class="controls">
        <button id="roll-button">Rolar Dado</button>
        <div id="result-display">Pressione o botão para rolar</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

// Configurações de física ajustadas para d4
const FRICTION = 0.98;
const WALL_BOUNCE_DAMPENING = 0.7; // Aumentado para mais quiques
const MIN_VELOCITY = 2.5; // Reduzido para permitir mais quiques
const MAX_VELOCITY = 25;
const INITIAL_FORCE_MULTIPLIER = 25; // Aumentado para mais força inicial
const COLLISION_COOLDOWN = 300;
const DICE_SIZE = 50;
const ROTATION_SPEED = 2;
const BOUNCE_HEIGHT_MULTIPLIER = 2.5; // Novo: multiplica altura dos quiques
const INITIAL_BOUNCE_COUNT = 5; // Mais quiques iniciais

// Configurações de escala
const SCALE = {
    MIN: 0.8,
    MAX: 2.0,
    FLIGHT: 1.5,
    BOUNCE: 1.3
};

// Setup Three.js
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.getElementById('dice-container').appendChild(renderer.domElement);

// Configurar câmera para visão top-down
camera.position.set(0, 10, 0);
camera.lookAt(0, 0, 0);
camera.rotation.z = Math.PI;

// Criar tetraedro
const geometry = new THREE.TetrahedronGeometry(1);
const material = new THREE.MeshPhongMaterial({
    color: 0x1a237e,
    shininess: 100,
    specular: 0x444444
});
const dice = new THREE.Mesh(geometry, material);
scene.add(dice);

// Iluminação
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(5, 5, 5);
scene.add(light);
scene.add(new THREE.AmbientLight(0x404040));

// Estado do dado
let isRolling = false;
let pressStartTime = 0;
let velocity = new THREE.Vector2();
let angularVelocity = new THREE.Vector3();
let phase = 'ready';
let flightTime = 0;
let bounceCount = INITIAL_BOUNCE_COUNT;
let lastCollisionTime = 0;

// Função para gerar número aleatório
function random(min, max) {
    return Math.random() * (max - min) + min;
}

// Função para determinar face superior
function getTopFace() {
    const normalMatrix = new THREE.Matrix3();
    normalMatrix.setFromMatrix4(dice.matrixWorld);
    
    const upVector = new THREE.Vector3(0, 1, 0);
    const faces = [
        new THREE.Vector3(0, 0, 1),  // 1
        new THREE.Vector3(1, 0, 0),  // 2
        new THREE.Vector3(0, 1, 0),  // 3
        new THREE.Vector3(-1, 0, 0)  // 4
    ];
    
    let maxDot = -1;
    let result = 1;
    
    faces.forEach((normal, index) => {
        normal.applyMatrix3(normalMatrix);
        const dot = normal.dot(upVector);
        if (dot > maxDot) {
            maxDot = dot;
            result = index + 1;
        }
    });
    
    return result;
}
        // Função de animação
function animate() {
    if (!isRolling) {
        renderer.render(scene, camera);
        return;
    }

    requestAnimationFrame(animate);

    switch (phase) {
        case 'throwing':
            dice.position.x += velocity.x;
            dice.position.z += velocity.y;
            
            flightTime += 0.05;
            const height = Math.sin(flightTime * Math.PI) * BOUNCE_HEIGHT_MULTIPLIER;
            dice.position.y = Math.max(0, height * 2);
            
            // Rotação mais agressiva durante o voo
            dice.rotation.x += angularVelocity.x * 1.5;
            dice.rotation.y += angularVelocity.y * 1.5;
            dice.rotation.z += angularVelocity.z * 1.5;
            
            if (flightTime >= 1) {
                phase = 'bouncing';
                bounceCount = INITIAL_BOUNCE_COUNT;
                flightTime = 0;
                velocity.multiplyScalar(0.8);
            }
            break;

        case 'bouncing':
            dice.position.x += velocity.x;
            dice.position.z += velocity.y;
            velocity.multiplyScalar(FRICTION);
            
            flightTime += 0.1;
            // Quiques mais altos no início, diminuindo gradualmente
            const bounceHeight = Math.sin(flightTime * Math.PI) * 
                               (BOUNCE_HEIGHT_MULTIPLIER / (bounceCount * 0.5)) * 
                               Math.max(Math.abs(velocity.length()), 0.5);
            dice.position.y = Math.max(0, bounceHeight);
            
            // Rotação mais errática durante os quiques
            if (dice.position.y < 0.1) {
                angularVelocity.x = random(-0.3, 0.3);
                angularVelocity.y = random(-0.3, 0.3);
                angularVelocity.z = random(-0.3, 0.3);
            }
            
            dice.rotation.x += angularVelocity.x;
            dice.rotation.y += angularVelocity.y;
            dice.rotation.z += angularVelocity.z;
            
            // Colisões mais elásticas nas bordas
            if (dice.position.x <= -5 || dice.position.x >= 5) {
                dice.position.x = dice.position.x <= -5 ? -5 : 5;
                velocity.x *= -WALL_BOUNCE_DAMPENING;
                angularVelocity.z = random(-0.3, 0.3);
            }
            
            if (dice.position.z <= -5 || dice.position.z >= 5) {
                dice.position.z = dice.position.z <= -5 ? -5 : 5;
                velocity.y *= -WALL_BOUNCE_DAMPENING;
                angularVelocity.x = random(-0.3, 0.3);
            }
            
            if (flightTime >= 1) {
                bounceCount--;
                flightTime = 0;
                
                if (bounceCount <= 0) {
                    phase = 'rolling';
                    velocity.multiplyScalar(0.7);
                } else {
                    velocity.x += random(-0.2, 0.2);
                    velocity.y += random(-0.2, 0.2);
                }
            }
            break;

        case 'rolling':
            dice.position.x += velocity.x;
            dice.position.z += velocity.y;
            
            velocity.multiplyScalar(FRICTION);
            angularVelocity.multiplyScalar(FRICTION);
            
            dice.position.y = 0;
            dice.rotation.x += angularVelocity.x;
            dice.rotation.y += angularVelocity.y;
            dice.rotation.z += angularVelocity.z;
            
            if (dice.position.x <= -5 || dice.position.x >= 5) {
                dice.position.x = dice.position.x <= -5 ? -5 : 5;
                velocity.x *= -WALL_BOUNCE_DAMPENING;
                angularVelocity.z = random(-0.1, 0.1);
            }
            
            if (dice.position.z <= -5 || dice.position.z >= 5) {
                dice.position.z = dice.position.z <= -5 ? -5 : 5;
                velocity.y *= -WALL_BOUNCE_DAMPENING;
                angularVelocity.x = random(-0.1, 0.1);
            }
            
            if (velocity.length() < MIN_VELOCITY && angularVelocity.length() < 0.01) {
                const result = getTopFace();
                resultDisplay.textContent = `Resultado: ${result}`;
                
                isRolling = false;
                phase = 'ready';
                rollButton.disabled = false;
                
                console.log(`[2025-04-19 19:44:23] User jonasdemencia got result: ${result}`);
            }
            break;
    }

    renderer.render(scene, camera);
}

// Event Listeners para o botão
const rollButton = document.getElementById('roll-button');
const resultDisplay = document.getElementById('result-display');

rollButton.addEventListener("mousedown", () => {
    if (isRolling) return;
    pressStartTime = Date.now();
    rollButton.style.transform = 'scale(0.95)';
});

rollButton.addEventListener("mouseup", () => {
    if (isRolling) return;
    
    const pressDuration = Math.min(Date.now() - pressStartTime, 4000);
    const forceFactor = pressDuration / 4000;
    
    isRolling = true;
    rollButton.disabled = true;
    phase = 'throwing';
    
    // Direção sempre para cima (como no d6)
    const force = INITIAL_FORCE_MULTIPLIER * (0.5 + forceFactor * 0.5);
    velocity.set(
        random(-0.3, 0.3), // Pequena variação lateral
        -force * 0.8 // Força principal para cima (negativo pois Z é profundidade)
    );
    
    angularVelocity.set(
        random(-0.4, 0.4),
        random(-0.4, 0.4),
        random(-0.4, 0.4)
    );
    
    // Posição inicial na parte inferior da tela
    dice.position.set(0, 0, 5);
    dice.rotation.set(
        random(-Math.PI, Math.PI),
        random(-Math.PI, Math.PI),
        random(-Math.PI, Math.PI)
    );
    
    flightTime = 0;
    bounceCount = INITIAL_BOUNCE_COUNT;
    
    console.log(`[2025-04-19 19:44:23] User jonasdemencia rolled the dice`);
    requestAnimationFrame(animate);
    rollButton.style.transform = '';
});

// Ajuste de redimensionamento
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

// Renderização inicial
renderer.render(scene, camera);
console.log(`[2025-04-19 19:44:23] D4 initialized by user jonasdemencia`);
    </script>

    
</body>
</html>
