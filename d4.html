<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>D4 Realista com Física 3D (Cannon-es)</title>

    <style>
        /* Estilos CSS mantidos como antes */
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: radial-gradient(circle at center, #3a3a3a, #1a1a1a);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #dice-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(to top, rgba(26, 26, 26, 0.8), transparent);
            z-index: 10;
        }

        #roll-button {
            padding: 12px 25px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            background: linear-gradient(145deg, #5a5a5a, #3a3a3a);
            border: none;
            border-radius: 8px;
            color: #e0e0e0;
            text-shadow: 0px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5),
                        inset 0px 1px 1px rgba(255,255,255,0.2);
            transition: transform 0.15s ease;
        }

        #result-display {
            margin-top: 15px;
            font-size: 1.5rem;
            color: #fff;
            min-height: 2rem;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="dice-container"></div>
    <div class="controls">
        <button id="roll-button">Rolar Dado</button>
        <div id="result-display">Pressione o botão para rolar</div>
    </div>

    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
    "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
  }
}
</script>


    <script type="module">
       import * as THREE from 'three';

import * as CANNON from 'cannon-es';

        // --- Configurações Globais ---
        // ... (código igual até a criação do mesh 'dice') ...
        // --- Constantes para Posição ---
const BASE_Z = 3; // Coordenada Z para a base/fundo da tela
const DICE_START_Y = 0.8; // Altura inicial/lançamento logo acima do chão
        const scene = new THREE.Scene();
        scene.background = new THREE.Color('#3a3a3a');
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('dice-container').appendChild(renderer.domElement);
        camera.position.set(0, 7, 0);
        camera.lookAt(0, 0, 0);
        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(5, 8, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xcccccc, 0.8));

        // --- Setup da Física (Cannon-es) ---
        const world = new CANNON.World({ gravity: new CANNON.Vec3(0, -9.82 * 2, 0) });
        world.allowSleep = true;
        world.broadphase = new CANNON.SAPBroadphase(world);
        const groundMaterial = new CANNON.Material('ground');
        const diceMaterial = new CANNON.Material('dice');
        const groundDiceContact = new CANNON.ContactMaterial(groundMaterial, diceMaterial, { friction: 0.2, restitution: 0.4 });
        world.addContactMaterial(groundDiceContact);
        const groundShape = new CANNON.Plane();
        const groundBody = new CANNON.Body({ mass: 0, shape: groundShape, material: groundMaterial });
        groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        groundBody.position.set(0, -0.1, 0);
        world.addBody(groundBody);

        // Criar paredes físicas
const wallShape = new CANNON.Plane();
const wallMaterial = new CANNON.Material('wall');

// Parede superior (Z positivo)
const topWall = new CANNON.Body({ mass: 0, shape: wallShape, material: wallMaterial });
topWall.quaternion.setFromEuler(0, 0, Math.PI); // Mudança crucial na orientação
topWall.position.set(0, 0, -5); // Posição mais próxima
world.addBody(topWall);

// Paredes laterais
const leftWall = new CANNON.Body({ mass: 0, shape: wallShape, material: wallMaterial });
leftWall.quaternion.setFromEuler(0, Math.PI/2, 0);
leftWall.position.set(-5, 0, 0);
world.addBody(leftWall);

const rightWall = new CANNON.Body({ mass: 0, shape: wallShape, material: wallMaterial });
rightWall.quaternion.setFromEuler(0, -Math.PI/2, 0);
rightWall.position.set(5, 0, 0);
world.addBody(rightWall);

// Parede INFERIOR
const bottomWall = new CANNON.Body({ mass: 0, shape: wallShape, material: wallMaterial });
bottomWall.quaternion.setFromEuler(0, 0, 0);
bottomWall.position.set(0, 0, BASE_Z - 0.1);

// Material de contato para as paredes
const wallDiceContact = new CANNON.ContactMaterial(wallMaterial, diceMaterial, {
    friction: 0.3,
    restitution: 0.8  // Aumentar para mais quiques
});
world.addContactMaterial(wallDiceContact);


         // --- Criação do Dado (Three.js) ---
function createDiceTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 512; // Largura da textura
    canvas.height = 512; // Altura da textura
    const ctx = canvas.getContext('2d');
    const halfWidth = canvas.width / 2;
    const halfHeight = canvas.height / 2;

    // Limpa e preenche o fundo
    ctx.fillStyle = '#1a237e'; // Cor de fundo do dado
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Configurações de texto
    ctx.fillStyle = 'white'; // Cor dos números
    ctx.font = 'bold 90px Arial'; // Tamanho da fonte (ajuste se necessário)
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // Função auxiliar para desenhar texto rotacionado
    function drawRotatedText(text, x, y, rotation) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(rotation);
        ctx.fillText(text, 0, 0);
        ctx.restore();
    }

    // --- Lógica de Desenho CORRETA para "Top Vertex" ---

    // 1. Definir as posições dos cantos DENTRO de cada quadrante da textura.
    //    Estes são os pontos onde os números serão desenhados.
    //    (Aproximações visuais, podem precisar de ajuste fino).
    //    Formato: [ [canto0_xy, canto1_xy, canto2_xy], ... ] para cada quadrante
    const quadrantCornerPositions = [
        // Quadrante 0 (Top-Left)
        [ { x: 128, y: 58, angle: 0 }, { x: 58, y: 198, angle: -Math.PI / 3 }, { x: 198, y: 198, angle: Math.PI / 3 } ],
        // Quadrante 1 (Top-Right)
        [ { x: 384, y: 58, angle: 0 }, { x: 314, y: 198, angle: -Math.PI / 3 }, { x: 454, y: 198, angle: Math.PI / 3 } ],
        // Quadrante 2 (Bottom-Left)
        [ { x: 128, y: 314+58, angle: 0 }, { x: 58, y: 314+198, angle: -Math.PI / 3 }, { x: 198, y: 314+198, angle: Math.PI / 3 } ], // Ajustado Y para quadrante inferior
        // Quadrante 3 (Bottom-Right)
        [ { x: 384, y: 314+58, angle: 0 }, { x: 314, y: 314+198, angle: -Math.PI / 3 }, { x: 454, y: 314+198, angle: Math.PI / 3 } ] // Ajustado Y para quadrante inferior
    ];
    // Offset para desenhar um pouco para dentro do canto
    const offsetFromCorner = 45;

    // 2. Mapeamento CRUCIAL: Qual vértice lógico (V0-V3, resultado 1-4) corresponde
    //    a qual canto (índice 0, 1 ou 2) em qual quadrante da textura (índice 0, 1, 2 ou 3)?
    //    Este mapeamento DEPENDE da forma como a THREE.TetrahedronGeometry e o loop UV
    //    mapeiam a geometria 3D para a textura 2D.
    //    --- ESTA É A PARTE MAIS DIFÍCIL E PROPENSA A ERROS ---
    //    Formato: vertexMap[vertexIndex] = [ { quadrant: qIdx, corner: cIdx }, ... ] (3 entradas por vértice)

    //    TENTATIVA DE MAPEAMENTO (BASEADA EM UMA POSSÍVEL DESMONTAGEM PADRÃO - PRECISA SER VALIDADA):
    //    V0 (Res 1) -> Canto 0 do Q0, Canto 0 do Q1, Canto 0 do Q3 ??
    //    V1 (Res 2) -> Canto 1 do Q0, Canto 1 do Q2, Canto 2 do Q3 ??
    //    V2 (Res 3) -> Canto 2 do Q0, Canto 0 do Q2, Canto 1 do Q1 ??
    //    V3 (Res 4) -> Canto 2 do Q1, Canto 2 do Q2, Canto 1 do Q3 ??

    //    Vamos definir o mapeamento explicitamente:
    const vertexMap = [
        // Vértice 0 (Resultado '1') - Onde o '1' deve aparecer?
        [ { quadrant: 0, corner: 0 }, { quadrant: 1, corner: 0 }, { quadrant: 3, corner: 0 } ], // Suposição: V0 é o canto 0 em 3 quadrantes
        // Vértice 1 (Resultado '2') - Onde o '2' deve aparecer?
        [ { quadrant: 0, corner: 1 }, { quadrant: 2, corner: 1 }, { quadrant: 3, corner: 2 } ], // Suposição
        // Vértice 2 (Resultado '3') - Onde o '3' deve aparecer?
        [ { quadrant: 0, corner: 2 }, { quadrant: 1, corner: 1 }, { quadrant: 2, corner: 0 } ], // Suposição
        // Vértice 3 (Resultado '4') - Onde o '4' deve aparecer?
        [ { quadrant: 1, corner: 2 }, { quadrant: 2, corner: 2 }, { quadrant: 3, corner: 1 } ]  // Suposição
    ];

     // 3. Desenhar os números
     for (let vertexIndex = 0; vertexIndex < 4; vertexIndex++) {
         const resultText = String(vertexIndex + 1); // O número a ser desenhado (1, 2, 3 ou 4)
         const placements = vertexMap[vertexIndex]; // Onde este número deve ser desenhado

         placements.forEach(placement => {
             const quadrantIdx = placement.quadrant;
             const cornerIdx = placement.corner;

             // Pega a posição e ângulo definidos para este canto neste quadrante
             const cornerData = quadrantCornerPositions[quadrantIdx][cornerIdx];
             const cornerX = cornerData.x;
             const cornerY = cornerData.y;
             // Usar um ângulo fixo pré-definido ou calcular dinamicamente? Vamos usar o pré-definido.
             const angle = cornerData.angle;

             // Calcular posição de desenho (offset para dentro) - Simplificado
             let drawX = cornerX;
             let drawY = cornerY;
             // Ajusta a posição para afastar do canto na direção aproximada do ângulo
             drawX += Math.sin(angle) * offsetFromCorner; // sen(0)=0, sen(+-pi/3)=+-0.86
             drawY -= Math.cos(angle) * offsetFromCorner; // cos(0)=1, cos(+-pi/3)=0.5

            // --- AJUSTE MANUAL DE POSIÇÃO (SE NECESSÁRIO) ---
            // Se a lógica acima não ficar boa, descomente e ajuste manualmente:
            // if (quadrantIdx === 0 && cornerIdx === 0) { drawX=...; drawY=...; angle=...; }
            // else if (quadrantIdx === 0 && cornerIdx === 1) { drawX=...; drawY=...; angle=...; }
            // ... etc para todas as 12 posições ...
            // --- FIM AJUSTE MANUAL ---

             drawRotatedText(resultText, drawX, drawY, angle);
         });
     }

    // Linhas de grade para ajudar a visualizar os quadrantes e cantos (REMOVER para produção)
    /*
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(halfWidth, 0); ctx.lineTo(halfWidth, canvas.height);
    ctx.moveTo(0, halfHeight); ctx.lineTo(canvas.width, halfHeight);
    ctx.stroke();
    quadrantCornerPositions.forEach(quad => {
        quad.forEach(corner => {
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(corner.x, corner.y, 10, 0, Math.PI*2);
            ctx.fill();
        });
    });
    */

    return new THREE.CanvasTexture(canvas);
}


// Criar geometria do tetraedro com tamanho 0.8
const geometry = new THREE.TetrahedronGeometry(0.8);

// Define as coordenadas UV para mapeamento da textura
// Isso controla como a textura é aplicada em cada face
const uvs = [];
for (let i = 0; i < 4; i++) { // 4 faces
    const u = i % 2 === 0 ? 0 : 0.5;
    const v = i < 2 ? 0 : 0.5;
    
    uvs.push(
        u, v,           // Primeiro vértice
        u + 0.5, v,     // Segundo vértice
        u + 0.25, v + 0.5 // Terceiro vértice
    );
}

// Aplica as coordenadas UV à geometria
geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));

// Criar material com a textura
const texture = createDiceTexture();
const material = new THREE.MeshStandardMaterial({
    map: texture,
    roughness: 0.3,  // Controla o quão fosco é o material
    metalness: 0.2   // Controla o aspecto metálico do material
});

// Criar o dado e adicionar à cena
const dice = new THREE.Mesh(geometry, material);
scene.add(dice);
        

        // --- Criação do Corpo Físico do Dado (Cannon-es) --- [INÍCIO DA SEÇÃO CORRIGIDA E LIMPA]
        // Extrair vértices da geometria não indexada do Three.js
        const vertices = geometry.attributes.position.array;
        const cannonVertices = [];
        for (let i = 0; i < vertices.length; i += 3) {
            cannonVertices.push(new CANNON.Vec3(vertices[i], vertices[i + 1], vertices[i + 2]));
        }

        // Definir as faces manualmente para geometria não indexada
        // O array 'vertices' acima terá 12 entradas (4 faces * 3 vértices/face).
        // As faces referenciam os índices DENTRO do array cannonVertices (0 a 11).
        const cannonFaces = [
            [0, 1, 2],  // Face 1 (usa os 3 primeiros vértices do array)
            [3, 4, 5],  // Face 2 (usa os 3 próximos vértices)
            [6, 7, 8],  // Face 3
            [9, 10, 11] // Face 4
        ];

        // Cria a forma convexa usando os vértices e as faces definidas
        const diceShape = new CANNON.ConvexPolyhedron({ vertices: cannonVertices, faces: cannonFaces });

        // Cria o corpo físico
        const diceBody = new CANNON.Body({
            mass: 1.5, // Massa do dado (afeta impulsos)
            shape: diceShape,
            material: diceMaterial,
            angularDamping: 0.4, // Amortecimento rotacional (ajuda a parar de girar)
            linearDamping: 0.2   // Amortecimento linear (ajuda a parar de deslizar)
        });
        diceBody.position.set(0, DICE_START_Y, BASE_Z); // Define a POSIÇÃO INICIAL na base da tela
        world.addBody(diceBody);
        // --- [FIM DA SEÇÃO CORRIGIDA E LIMPA] ---



        // --- Estado e Controles ---
        let isRolling = false;
        const rollButton = document.getElementById('roll-button');
        const resultDisplay = document.getElementById('result-display');

        // Variáveis para controle de força
let pressStartTime = 0;
let maxPressTime = 2000; // 2 segundos para força máxima
let minForce = 15;
let maxForce = 40;

        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        // Função para obter resultado (lê orientação do MESH Three.js)
        function getResultFromTopVertex() {
            // ... (código da função igual ao anterior) ...
             const vertices = [
                 new THREE.Vector3(1, 1, 1), new THREE.Vector3(-1, -1, 1),
                 new THREE.Vector3(-1, 1, -1), new THREE.Vector3(1, -1, -1)
             ];
             const worldVertices = vertices.map(v => v.clone().applyMatrix4(dice.matrixWorld));
             let highestVertexIndex = -1;
             let maxY = -Infinity;
             for (let i = 0; i < worldVertices.length; i++) {
                 if (worldVertices[i].y > maxY) {
                     maxY = worldVertices[i].y;
                     highestVertexIndex = i;
                 }
             }
             // !! IMPORTANTE: VERIFICAR ESTE MAPEAMENTO !!
             const vertexIndexToResultMap = [1, 2, 3, 4]; // Suposição inicial
             return vertexIndexToResultMap[highestVertexIndex] || 'Erro';
        }

        // --- Lógica de Rolagem (Physics Based) ---
        // Event listeners do botão
rollButton.addEventListener("mousedown", () => {
    if (isRolling) return;
    pressStartTime = Date.now();
    // Adiciona feedback visual
    rollButton.style.transform = 'scale(0.95)';
    resultDisplay.textContent = "Segure para aumentar a força...";
});

rollButton.addEventListener("mouseup", () => {
    if (isRolling) return;
    
    // Calcula a força baseada no tempo pressionado
    const pressDuration = Date.now() - pressStartTime;
    const forcePercent = Math.min(pressDuration / maxPressTime, 1);
    const throwSpeed = minForce + (maxForce - minForce) * forcePercent;
    
    isRolling = true;
    rollButton.disabled = true;
    resultDisplay.textContent = `Rolando com ${Math.round(forcePercent * 100)}% de força!`;
    rollButton.style.transform = '';
    
    diceBody.wakeUp();

    // Posição inicial
    diceBody.position.set(0, DICE_START_Y, BASE_Z);
    diceBody.velocity.set(0, 0, 0);
    diceBody.angularVelocity.set(0, 0, 0);

    // Rotação inicial aleatória
    diceBody.quaternion.setFromEuler(
        random(0, Math.PI * 2),
        random(0, Math.PI * 2),
        random(0, Math.PI * 2)
    );

    // Direção do impulso com força variável
    const impulseDirection = new CANNON.Vec3(
        random(-0.2, 0.2),
        0.3 + Math.random() * 0.4,
        -5 * (forcePercent + 0.5) // Força aumenta com o tempo pressionado
    );
    impulseDirection.normalize();

    // Aplica o impulso com a força calculada
    diceBody.applyImpulse(
        impulseDirection.scale(throwSpeed),
        new CANNON.Vec3(0, 0, 0)
    );

    // Torque também aumenta com a força
    const torqueAxis = new CANNON.Vec3(
        random(-1, 1),
        random(-1, 1),
        random(-1, 1)
    ).normalize();
    diceBody.applyTorque(torqueAxis.scale(5 + random(0, 2) * forcePercent * 3));

    console.log(`[${new Date().toISOString()}] Dice Roll Triggered with ${Math.round(forcePercent * 100)}% force`);
});

        // --- Evento de Repouso (Sleep) ---
        diceBody.addEventListener('sleep', () => {
            // ... (código igual ao anterior para detectar parada e mostrar resultado) ...
             console.log("Dice physics body has fallen asleep.");
             if (isRolling) {
                 isRolling = false;
                 rollButton.disabled = false;
                 diceBody.velocity.set(0, 0, 0);
                 diceBody.angularVelocity.set(0, 0, 0);
                 dice.position.copy(diceBody.position);
                 dice.quaternion.copy(diceBody.quaternion);
                 const result = getResultFromTopVertex();
                 resultDisplay.textContent = `Resultado: ${result}`;
                 console.log(`[${new Date().toISOString()}] Result Determined (Physics Sleep): ${result}`);
             }
        });

        // --- Loop de Animação ---
        const clock = new THREE.Clock();
        let lastTime = 0;
        function animate() {
            // ... (código igual ao anterior) ...
            requestAnimationFrame(animate);
            const time = performance.now() / 1000;
            const deltaTime = time - lastTime;
            lastTime = time;
            if (deltaTime > 0) {
                 // world.step(1/60, deltaTime); // Opção de timestep fixo
                 world.step(deltaTime); // Timestep variável
            }
            dice.position.copy(diceBody.position);
            dice.quaternion.copy(diceBody.quaternion);
            renderer.render(scene, camera);
        }

        // --- Inicialização ---
        window.addEventListener('resize', () => { /* ...código igual... */ });
        dice.position.copy(diceBody.position); // Sinc inicial (opcional)
        dice.quaternion.copy(diceBody.quaternion); // Sinc inicial (opcional)
        animate(); // Inicia o loop
        console.log(`[${new Date().toISOString()}] D4 Initialized with Cannon-es`);

    </script>
    
</body>
</html>
