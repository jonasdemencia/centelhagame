<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>D4 Realista com Física 2D</title>

    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: radial-gradient(circle at center, #3a3a3a, #1a1a1a);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #dice-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        .controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(to top, rgba(26, 26, 26, 0.8), transparent);
            z-index: 10;
        }

        #roll-button {
            padding: 12px 25px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            background: linear-gradient(145deg, #5a5a5a, #3a3a3a);
            border: none;
            border-radius: 8px;
            color: #e0e0e0;
            text-shadow: 0px 1px 2px rgba(0,0,0,0.5);
            box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5),
                        inset 0px 1px 1px rgba(255,255,255,0.2);
            transition: transform 0.15s ease;
        }

        #result-display {
            margin-top: 15px;
            font-size: 1.5rem;
            color: #fff;
            min-height: 2rem;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
    </style>
</head>
<body>
    <div id="dice-container"></div>
    <div class="controls">
        <button id="roll-button">Rolar Dado</button>
        <div id="result-display">Pressione o botão para rolar</div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // Configurações de física (mantidas do seu código original)
        const FRICTION = 0.98;
        const WALL_BOUNCE_DAMPENING = 0.5;
        const MIN_VELOCITY = 3.5;
        const MAX_VELOCITY = 25;
        const INITIAL_FORCE_MULTIPLIER = 35;
        const COLLISION_COOLDOWN = 300;
        const DICE_SIZE = 50;
        const ROTATION_SPEED = 2;

        // Configurações de escala
        const SCALE = {
            MIN: 0.8,
            MAX: 2.0,
            FLIGHT: 1.5,
            BOUNCE: 1.3
        };

        // Setup Three.js
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('dice-container').appendChild(renderer.domElement);

        // Configurar câmera para visão top-down
        camera.position.set(0, 10, 0);
        camera.lookAt(0, 0, 0);
        camera.rotation.z = Math.PI; // Ajuste para manter orientação consistente

        // Criar tetraedro
        const geometry = new THREE.TetrahedronGeometry(1);
        const material = new THREE.MeshPhongMaterial({
            color: 0x1a237e,
            shininess: 100,
            specular: 0x444444
        });
        const dice = new THREE.Mesh(geometry, material);
        scene.add(dice);

        // Iluminação
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 5, 5);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // Estado do dado
        let isRolling = false;
        let pressStartTime = 0;
        let velocity = new THREE.Vector2();
        let angularVelocity = new THREE.Vector3();
        let phase = 'ready';
        let flightTime = 0;
        let bounceCount = 0;
        let lastCollisionTime = 0;

        // Função para gerar número aleatório
        function random(min, max) {
            return Math.random() * (max - min) + min;
        }

        // Função para determinar face superior
        function getTopFace() {
            const normalMatrix = new THREE.Matrix3();
            normalMatrix.setFromMatrix4(dice.matrixWorld);
            
            const upVector = new THREE.Vector3(0, 1, 0);
            const faces = [
                new THREE.Vector3(0, 0, 1),  // 1
                new THREE.Vector3(1, 0, 0),  // 2
                new THREE.Vector3(0, 1, 0),  // 3
                new THREE.Vector3(-1, 0, 0)  // 4
            ];
            
            let maxDot = -1;
            let result = 1;
            
            faces.forEach((normal, index) => {
                normal.applyMatrix3(normalMatrix);
                const dot = normal.dot(upVector);
                if (dot > maxDot) {
                    maxDot = dot;
                    result = index + 1;
                }
            });
            
            return result;
        }

        // Função de animação
        function animate() {
            if (!isRolling) {
                renderer.render(scene, camera);
                return;
            }

            requestAnimationFrame(animate);

            switch (phase) {
                case 'throwing':
                    // Código de lançamento
                    dice.position.x += velocity.x;
                    dice.position.z += velocity.y;
                    
                    flightTime += 0.05;
                    const height = Math.sin(flightTime * Math.PI);
                    dice.position.y = height * 2;
                    
                    dice.rotation.x += angularVelocity.x;
                    dice.rotation.y += angularVelocity.y;
                    dice.rotation.z += angularVelocity.z;
                    
                    if (flightTime >= 1) {
                        phase = 'bouncing';
                        bounceCount = 3;
                        flightTime = 0;
                    }
                    break;

                            case 'bouncing':
                    dice.position.x += velocity.x;
                    dice.position.z += velocity.y;
                    velocity.x *= FRICTION;
                    velocity.y *= FRICTION;
                    
                    flightTime += 0.1;
                    const bounceHeight = Math.sin(flightTime * Math.PI) * (SCALE.BOUNCE / (bounceCount + 1));
                    dice.position.y = bounceHeight;
                    
                    // Colisões com as bordas da tela
                    if (dice.position.x <= -5 || dice.position.x >= 5) {
                        dice.position.x = dice.position.x <= -5 ? -5 : 5;
                        velocity.x *= -WALL_BOUNCE_DAMPENING;
                        
                        // Rotação na colisão
                        angularVelocity.z = random(-0.2, 0.2);
                        angularVelocity.y = random(-0.2, 0.2);
                    }
                    
                    if (dice.position.z <= -5 || dice.position.z >= 5) {
                        dice.position.z = dice.position.z <= -5 ? -5 : 5;
                        velocity.y *= -WALL_BOUNCE_DAMPENING;
                        
                        // Rotação na colisão
                        angularVelocity.x = random(-0.2, 0.2);
                        angularVelocity.y = random(-0.2, 0.2);
                    }
                    
                    if (flightTime >= 1) {
                        bounceCount--;
                        flightTime = 0;
                        
                        if (bounceCount <= 0) {
                            phase = 'rolling';
                            velocity.multiplyScalar(0.5);
                        }
                    }
                    break;

                case 'rolling':
                    // Movimento final
                    dice.position.x += velocity.x;
                    dice.position.z += velocity.y;
                    
                    // Aplicar fricção
                    velocity.multiplyScalar(FRICTION);
                    angularVelocity.multiplyScalar(FRICTION);
                    
                    // Manter o dado no chão
                    dice.position.y = 0;
                    
                    // Rotação durante o rolamento
                    dice.rotation.x += angularVelocity.x;
                    dice.rotation.y += angularVelocity.y;
                    dice.rotation.z += angularVelocity.z;
                    
                    // Colisões com as bordas
                    if (dice.position.x <= -5 || dice.position.x >= 5) {
                        dice.position.x = dice.position.x <= -5 ? -5 : 5;
                        velocity.x *= -WALL_BOUNCE_DAMPENING;
                        angularVelocity.z = random(-0.1, 0.1);
                    }
                    
                    if (dice.position.z <= -5 || dice.position.z >= 5) {
                        dice.position.z = dice.position.z <= -5 ? -5 : 5;
                        velocity.y *= -WALL_BOUNCE_DAMPENING;
                        angularVelocity.x = random(-0.1, 0.1);
                    }
                    
                    // Verificar se o dado parou
                    if (velocity.length() < MIN_VELOCITY && 
                        angularVelocity.length() < 0.01) {
                        
                        // Alinhar com a face mais próxima
                        const result = getTopFace();
                        resultDisplay.textContent = `Resultado: ${result}`;
                        
                        isRolling = false;
                        phase = 'ready';
                        rollButton.disabled = false;
                        
                        console.log(`[2025-04-19 19:23:54] User jonasdemencia got result: ${result}`);
                    }
                    break;
            }

            renderer.render(scene, camera);
        }

        // Event Listeners para o botão
        const rollButton = document.getElementById('roll-button');
        const resultDisplay = document.getElementById('result-display');

        rollButton.addEventListener("mousedown", () => {
            if (isRolling) return;
            pressStartTime = Date.now();
            rollButton.style.transform = 'scale(0.95)';
        });

        rollButton.addEventListener("mouseup", () => {
            if (isRolling) return;
            
            const pressDuration = Math.min(Date.now() - pressStartTime, 4000);
            const forceFactor = pressDuration / 4000;
            
            isRolling = true;
            rollButton.disabled = true;
            phase = 'throwing';
            
            // Configurar velocidades iniciais
            velocity.set(
                random(-0.1, 0.1) * INITIAL_FORCE_MULTIPLIER * (0.5 + forceFactor * 0.5),
                random(-0.1, 0.1) * INITIAL_FORCE_MULTIPLIER * (0.5 + forceFactor * 0.5)
            );
            
            angularVelocity.set(
                random(-0.2, 0.2),
                random(-0.2, 0.2),
                random(-0.2, 0.2)
            );
            
            // Resetar posição e rotação
            dice.position.set(0, 0, 0);
            dice.rotation.set(0, 0, 0);
            flightTime = 0;
            
            // Iniciar animação
            requestAnimationFrame(animate);
            rollButton.style.transform = '';
            
            console.log(`[2025-04-19 19:23:54] User jonasdemencia rolled the dice`);
        });

        // Ajuste de redimensionamento
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Renderização inicial
        renderer.render(scene, camera);
        console.log(`[2025-04-19 19:23:54] D4 initialized by user jonasdemencia`);
    </script>
</body>
</html>
