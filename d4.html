<!DOCTYPE html>
 <html lang="en">
 <head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
     <title>D4 Realista com F√≠sica 2D</title>
 
     <style>
         body {
             display: flex;
             flex-direction: column;
             justify-content: flex-end;
             align-items: center;
             height: 100vh;
             margin: 0;
             background: radial-gradient(circle at center, #3a3a3a, #1a1a1a);
             font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
             overflow: hidden;
             user-select: none;
         }
 
         #dice-container {
             position: absolute;
             top: 0;
             left: 0;
             width: 100%;
             height: 100%;
             overflow: hidden;
         }
 
         .controls {
             position: fixed;
             bottom: 0;
             left: 0;
             width: 100%;
             padding: 20px;
             box-sizing: border-box;
             display: flex;
             flex-direction: column;
             align-items: center;
             background: linear-gradient(to top, rgba(26, 26, 26, 0.8), transparent);
             z-index: 10;
         }
 
         #roll-button {
             padding: 12px 25px;
             font-size: 1.1rem;
             font-weight: bold;
             cursor: pointer;
             background: linear-gradient(145deg, #5a5a5a, #3a3a3a);
             border: none;
             border-radius: 8px;
             color: #e0e0e0;
             text-shadow: 0px 1px 2px rgba(0,0,0,0.5);
             box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.5),
                         inset 0px 1px 1px rgba(255,255,255,0.2);
             transition: transform 0.15s ease;
         }
 
         #result-display {
             margin-top: 15px;
             font-size: 1.5rem;
             color: #fff;
             min-height: 2rem;
             font-weight: bold;
             text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
         }
     </style>
 </head>
 <body>
     <div id="dice-container"></div>
     <div class="controls">
         <button id="roll-button">Rolar Dado</button>
         <div id="result-display">Pressione o bot√£o para rolar</div>
     </div>
 
     <script type="importmap">
 {
   "imports": {
     "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
     "three/examples/jsm/loaders/FontLoader.js": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/FontLoader.js",
     "three/examples/jsm/geometries/TextGeometry.js": "https://unpkg.com/three@0.160.0/examples/jsm/geometries/TextGeometry.js"
   }
 }
 </script>
 
 
     <script type="module">
         import * as THREE from 'three';
         import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
         import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
 
 
 
 // Configura√ß√µes de f√≠sica ajustadas para comportamento de tetraedro
 const FRICTION = 0.95;                    // Reduzido para manter mais momentum
 const WALL_BOUNCE_DAMPENING = 0.8;        // Aumentado para manter mais energia
 const MIN_VELOCITY = 0.02;                // Reduzido para parar mais suavemente
 const MAX_VELOCITY = 5;                   // Reduzido significativamente
 const INITIAL_FORCE_MULTIPLIER = 2;       // For√ßa inicial muito menor
 const COLLISION_COOLDOWN = 150;           // Reduzido para permitir colis√µes mais frequentes
 const ROTATION_SPEED = 1.5;               // Rota√ß√£o mais lenta
 const BOUNCE_HEIGHT_MULTIPLIER = 2.0;     // Aumentado para quiques mais altos
 const INITIAL_BOUNCE_COUNT = 4;           // Menos quiques
 const TUMBLE_FACTOR = 0.6;               // Aumentado para mais movimento ap√≥s colis√£o
 const VERTEX_IMPACT_CHANCE = 0.7;         // Novo: chance de impacto no v√©rtice

 let targetQuaternion = null;
 let aligning = false;

 // Configura√ß√µes de escala para visual mais realista
 const SCALE = {
     MIN: 0.8,
     MAX: 1.5,    // Reduzido para n√£o parecer que voa muito alto
     FLIGHT: 1.2,
     BOUNCE: 1.1
 };
 
 // Setup Three.js (mantido como estava)
 const scene = new THREE.Scene();
 scene.background = new THREE.Color('#3a3a3a'); // fundo cinza escuro igual ao d6
 const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
 const renderer = new THREE.WebGLRenderer({ antialias: true });
 renderer.setSize(window.innerWidth, window.innerHeight);
 document.getElementById('dice-container').appendChild(renderer.domElement);
 
 // Configurar c√¢mera para vis√£o top-down
 camera.position.set(0, 10, 0);
 camera.lookAt(0, 0, 0);
 camera.rotation.z = Math.PI;
 
 // Criar tetraedro com material mais realista
 const geometry = new THREE.TetrahedronGeometry(1);
 const material = new THREE.MeshPhongMaterial({
     color: 0x1a237e,
     shininess: 70,
     specular: 0x333333,
     flatShading: true
 });
 // Logo ap√≥s criar o dado, definir sua posi√ß√£o inicial
 const dice = new THREE.Mesh(geometry, material);
 scene.add(dice);
 
 // Carregar fonte padr√£o do Three.js
 const loader = new FontLoader();
 loader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', function (font) {
     const textMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
 
     // Posi√ß√µes ajustadas para ter 3 n√∫meros iguais ao redor de cada v√©rtice
     const numberPositions = [
         // N√∫meros 1 (tr√™s vezes ao redor do primeiro v√©rtice)
         { pos: new THREE.Vector3(-0.4, 0.2, -0.2), rot: new THREE.Euler(-0.5, -0.5, 0), text: '1' },
         { pos: new THREE.Vector3(-0.2, 0.2, 0.4), rot: new THREE.Euler(-0.5, -0.5, 0), text: '1' },
         { pos: new THREE.Vector3(-0.4, -0.2, 0.2), rot: new THREE.Euler(0.5, -0.5, 0), text: '1' },
 
         // N√∫meros 2 (tr√™s vezes ao redor do segundo v√©rtice)
         { pos: new THREE.Vector3(0.4, 0.2, -0.2), rot: new THREE.Euler(-0.5, 0.5, 0), text: '2' },
         { pos: new THREE.Vector3(0.2, 0.2, 0.4), rot: new THREE.Euler(-0.5, 0.5, 0), text: '2' },
         { pos: new THREE.Vector3(0.4, -0.2, 0.2), rot: new THREE.Euler(0.5, 0.5, 0), text: '2' },
 
         // N√∫meros 3 (tr√™s vezes ao redor do terceiro v√©rtice)
         { pos: new THREE.Vector3(0, -0.4, -0.2), rot: new THREE.Euler(0.5, 0, 0), text: '3' },
         { pos: new THREE.Vector3(-0.2, -0.4, 0.2), rot: new THREE.Euler(0.5, -0.5, 0), text: '3' },
         { pos: new THREE.Vector3(0.2, -0.4, 0.2), rot: new THREE.Euler(0.5, 0.5, 0), text: '3' },
 
         // N√∫meros 4 (tr√™s vezes ao redor do quarto v√©rtice)
         { pos: new THREE.Vector3(0, 0.4, 0.2), rot: new THREE.Euler(-0.5, 0, 0), text: '4' },
         { pos: new THREE.Vector3(-0.2, 0.3, 0.3), rot: new THREE.Euler(-0.5, -0.5, 0), text: '4' },
         { pos: new THREE.Vector3(0.2, 0.3, 0.3), rot: new THREE.Euler(-0.5, 0.5, 0), text: '4' }
     ];
 
     numberPositions.forEach(({ pos, rot, text }) => {
         const textGeo = new TextGeometry(text, {
             font: font,
             size: 0.2,         // Tamanho reduzido para caber tr√™s n√∫meros
             height: 0.01,      // Mant√©m fino
             curveSegments: 12,
             bevelEnabled: false
         });
 
         // Centralizar o texto
         textGeo.computeBoundingBox();
         const centerOffset = new THREE.Vector3(
             -(textGeo.boundingBox.max.x - textGeo.boundingBox.min.x) / 2,
             -(textGeo.boundingBox.max.y - textGeo.boundingBox.min.y) / 2,
             -(textGeo.boundingBox.max.z - textGeo.boundingBox.min.z) / 2
         );
 
         const textMesh = new THREE.Mesh(textGeo, textMaterial);
         textMesh.position.copy(pos).add(centerOffset);
         textMesh.rotation.copy(rot);
 
         // Adicionar direto ao dado
         dice.add(textMesh);
     });
 });
 
 
 // Ilumina√ß√£o ajustada
 const light = new THREE.DirectionalLight(0xffffff, 1.2);
 light.position.set(5, 8, 5);
 scene.add(light);
 scene.add(new THREE.AmbientLight(0x404040, 0.8));
 
 // Estado do dado
 let isRolling = false;
 let pressStartTime = 0;
 let velocity = new THREE.Vector2();
 let angularVelocity = new THREE.Vector3();
 let phase = 'ready';
 let flightTime = 0;
 let bounceCount = INITIAL_BOUNCE_COUNT;
 let lastCollisionTime = 0;
 let lastVertexImpact = 0;
 
 // Fun√ß√£o para simular impacto no v√©rtice
 function handleVertexImpact() {
     const currentTime = Date.now();
     if (currentTime - lastVertexImpact < 200) return false;
 
     if (Math.random() < VERTEX_IMPACT_CHANCE) {
         lastVertexImpact = currentTime;
         angularVelocity.set(
             random(-0.5, 0.5) * ROTATION_SPEED,
             random(-0.5, 0.5) * ROTATION_SPEED,
             random(-0.5, 0.5) * ROTATION_SPEED
         );
         return true;
     }
     return false;
 }
 
 function random(min, max) {
     return Math.random() * (max - min) + min;
 }

 function getTopVertexResult() {
    const positions = geometry.getAttribute('position');
    const matrix = dice.matrixWorld;

    let topVertexIndex = 0;
    let highestY = -Infinity;

    // Existem 4 v√©rtices: 0 a 3
    for (let i = 0; i < 4; i++) {
        const vertex = new THREE.Vector3().fromBufferAttribute(positions, i);
        vertex.applyMatrix4(matrix);

        if (vertex.y > highestY) {
            highestY = vertex.y;
            topVertexIndex = i;
        }
    }

    // Mapeamento do v√©rtice para o n√∫mero vis√≠vel
    // D4: cada n√∫mero est√° associado √† ponta oposta √† face que toca o ch√£o
    // Mapeamento arbitr√°rio: 0 ‚Üí 1, 1 ‚Üí 2, 2 ‚Üí 3, 3 ‚Üí 4
    return topVertexIndex + 1;
}

    function getTargetQuaternionFromBottomFace() {
    const position = geometry.getAttribute("position");
    const index = geometry.index.array;
    const matrix = dice.matrixWorld;

    let lowestFaceIndex = -1;
    let lowestY = Infinity;

    for (let i = 0; i < index.length; i += 3) {
        const a = new THREE.Vector3().fromBufferAttribute(position, index[i]);
        const b = new THREE.Vector3().fromBufferAttribute(position, index[i + 1]);
        const c = new THREE.Vector3().fromBufferAttribute(position, index[i + 2]);

        a.applyMatrix4(matrix);
        b.applyMatrix4(matrix);
        c.applyMatrix4(matrix);

        const centroid = new THREE.Vector3().addVectors(a, b).add(c).divideScalar(3);
        if (centroid.y < lowestY) {
            lowestY = centroid.y;
            lowestFaceIndex = i;
        }
    }

    // Pega a face mais baixa
    const a = new THREE.Vector3().fromBufferAttribute(position, index[lowestFaceIndex]);
    const b = new THREE.Vector3().fromBufferAttribute(position, index[lowestFaceIndex + 1]);
    const c = new THREE.Vector3().fromBufferAttribute(position, index[lowestFaceIndex + 2]);

    const ab = new THREE.Vector3().subVectors(b, a);
    const ac = new THREE.Vector3().subVectors(c, a);
    const normal = new THREE.Vector3().crossVectors(ab, ac).normalize();

    // Precisamos da rota√ß√£o que alinha a normal da face com o eixo Y
    const up = new THREE.Vector3(0, 1, 0);
    const quaternion = new THREE.Quaternion().setFromUnitVectors(normal, up);

    return quaternion;
}



 // Adicionar logo ap√≥s a fun√ß√£o random:
 function getTopFace() {
     const normalMatrix = new THREE.Matrix3();
     normalMatrix.setFromMatrix4(dice.matrixWorld);
 
     const upVector = new THREE.Vector3(0, 1, 0);
     const faces = [
         new THREE.Vector3(0, 0, 1),  // 1
         new THREE.Vector3(1, 0, 0),  // 2
         new THREE.Vector3(0, 1, 0),  // 3
         new THREE.Vector3(-1, 0, 0)  // 4
     ];
 
     let maxDot = -1;
     let result = 1;
 
     faces.forEach((normal, index) => {
         normal.applyMatrix3(normalMatrix);
         const dot = normal.dot(upVector);
         if (dot > maxDot) {
             maxDot = dot;
             result = index + 1;
         }
     });
 
     return result;
 }
 
 // Fun√ß√£o de anima√ß√£o ajustada para comportamento de tetraedro
 function animate() {
     if (!isRolling) {
         renderer.render(scene, camera);
         return;
     }
 
     requestAnimationFrame(animate);
 
     switch (phase) {
         case 'throwing':
             dice.position.x += velocity.x;
             dice.position.z += velocity.y;
 
             flightTime += 0.05;
             const height = Math.sin(flightTime * Math.PI) * BOUNCE_HEIGHT_MULTIPLIER;
             dice.position.y = Math.max(0, height * 2);
 
             // Rota√ß√£o mais err√°tica durante o voo
             dice.rotation.x += angularVelocity.x * (1 + random(-0.2, 0.2));
             dice.rotation.y += angularVelocity.y * (1 + random(-0.2, 0.2));
             dice.rotation.z += angularVelocity.z * (1 + random(-0.2, 0.2));
 
             if (flightTime >= 1) {
                 phase = 'bouncing';
                 bounceCount = INITIAL_BOUNCE_COUNT;
                 flightTime = 0;
                 handleVertexImpact();
             }
             break;
 
         case 'bouncing':
     dice.position.x += velocity.x * 0.5; // Reduzido movimento horizontal
     dice.position.z += velocity.y * 0.5;
     velocity.multiplyScalar(0.85); // Aumentado o atrito
 
     flightTime += 0.1;
     const bounceHeight = Math.sin(flightTime * Math.PI) * 
                         (BOUNCE_HEIGHT_MULTIPLIER / (bounceCount + 1)) * // Ajustado divisor
                         Math.max(Math.abs(velocity.length()), 0.2); // Reduzido valor m√≠nimo
 
     // Reduzidas as varia√ß√µes na altura
     dice.position.y = Math.max(0, bounceHeight + random(-0.05, 0.05));
 
     // Rota√ß√£o mais controlada durante os quiques
     if (dice.position.y < 0.1 && handleVertexImpact()) {
         velocity.x += random(-TUMBLE_FACTOR, TUMBLE_FACTOR) * 0.3; // Reduzido o fator
         velocity.y += random(-TUMBLE_FACTOR, TUMBLE_FACTOR) * 0.3;
         angularVelocity.multiplyScalar(0.8); // Reduz a rota√ß√£o mais rapidamente
     }
 
     // Rota√ß√µes mais suaves
     dice.rotation.x += angularVelocity.x * 0.7;
     dice.rotation.y += angularVelocity.y * 0.7;
     dice.rotation.z += angularVelocity.z * 0.7;
 
     // Colis√µes mais suaves
     if (dice.position.x <= -5 || dice.position.x >= 5) {
         dice.position.x = dice.position.x <= -5 ? -5 : 5;
         velocity.x *= -WALL_BOUNCE_DAMPENING * 1.7; // Reduzido o bounce
         if (handleVertexImpact()) {
             velocity.y += random(-TUMBLE_FACTOR, TUMBLE_FACTOR) * 0.3;
         }
     }
 
     if (dice.position.z <= -5 || dice.position.z >= 5) {
         dice.position.z = dice.position.z <= -5 ? -5 : 5;
         velocity.y *= -WALL_BOUNCE_DAMPENING * 1.7;
         if (handleVertexImpact()) {
             velocity.x += random(-TUMBLE_FACTOR, TUMBLE_FACTOR) * 0.3;
         }
     }
 
     if (flightTime >= 1) {
         bounceCount--;
         flightTime = 0;
 
         if (bounceCount <= 0 || velocity.length() < 0.1) { // Adicionada condi√ß√£o de velocidade
             phase = 'rolling';
             velocity.multiplyScalar(0.5); // Reduzido ainda mais
         } else {
             // Movimento err√°tico reduzido entre quiques
             velocity.x += random(-0.1, 0.1) * TUMBLE_FACTOR;
             velocity.y += random(-0.1, 0.1) * TUMBLE_FACTOR;
             handleVertexImpact();
         }
     }
     break;
 
         case 'rolling':
     dice.position.x += velocity.x * 0.5;  // Reduz o movimento horizontal
     dice.position.z += velocity.y * 0.5;
 
     velocity.multiplyScalar(0.85);        // Mais atrito
     angularVelocity.multiplyScalar(0.85);
 
     dice.position.y = 0.01;  // Mant√©m no ch√£o
 
     // Rota√ß√£o final muito mais suave
     dice.rotation.x += angularVelocity.x * 0.5;
     dice.rotation.y += angularVelocity.y * 0.5;
     dice.rotation.z += angularVelocity.z * 0.5;
 
     // Para o dado mais rapidamente
         // Para o dado mais rapidamente
    if ((velocity.length() < MIN_VELOCITY || angularVelocity.length() < 0.01) && !aligning) {
        const result = getTopVertexResult();
        resultDisplay.textContent = `Resultado: ${result}`;

        targetQuaternion = getTargetQuaternionFromBottomFace();
        aligning = true;
    }

    // Faz o alinhamento suave (depois que a f√≠sica parou)
    if (aligning && targetQuaternion) {
        dice.quaternion.slerp(targetQuaternion, 0.1);

        if (dice.quaternion.angleTo(targetQuaternion) < 0.01) {
            aligning = false;
            isRolling = false;
            phase = 'ready';
            rollButton.disabled = false;

            velocity.set(0, 0);
            angularVelocity.set(0, 0, 0);
        }
    }

    renderer.render(scene, camera);
} // üëà ESTE AQUI ESTAVA FALTANDO
 
 // Event Listeners para o bot√£o com lan√ßamento ajustado
 const rollButton = document.getElementById('roll-button');
 const resultDisplay = document.getElementById('result-display');
 
 function setInitialDicePosition() {
     dice.position.set(
         0,     // eixo X central
         0,     // no ch√£o
         -5.5    // eixo Z "mais pr√≥ximo da c√¢mera" = base inferior da tela
     );
 }
 
 // Chamada fora da fun√ß√£o
 setInitialDicePosition();
 
 
 rollButton.addEventListener("mousedown", () => {
     if (isRolling) return;
     pressStartTime = Date.now();
     rollButton.style.transform = 'scale(0.95)';
 });
 
 // No evento mouseup, ajustar o c√°lculo da posi√ß√£o
 rollButton.addEventListener("mouseup", () => {
     if (isRolling) return;
 
     const pressDuration = Math.min(Date.now() - pressStartTime, 4000);
     const forceFactor = pressDuration / 4000;
 
     isRolling = true;
     rollButton.disabled = true;
     phase = 'throwing';
 
     // For√ßa muito mais suave
     const force = INITIAL_FORCE_MULTIPLIER * (0.2 + forceFactor * 0.2);
 
     // Posi√ß√£o inicial abaixo do bot√£o
     const buttonRect = rollButton.getBoundingClientRect();
     const buttonBottomWorld = (buttonRect.bottom / window.innerHeight) * 10 - 4;
 
     dice.position.set(
     0,
     0,
     -5.5 // mesma base inferior da tela
 );
 
     // Movimento para cima na tela (Z positivo, pois a c√¢mera olha de cima)
 velocity.set(
     random(-0.05, 0.05),   // leve varia√ß√£o lateral
     force * 1.5            // for√ßa forte no eixo Z para subir at√© o topo
 );
 
 
     dice.rotation.set(
         random(-Math.PI/4, Math.PI/4),
         random(-Math.PI/4, Math.PI/4),
         random(-Math.PI/4, Math.PI/4)
     );
 
     flightTime = 0;
     bounceCount = INITIAL_BOUNCE_COUNT;
 
     console.log(`[2025-04-19 22:17:11] User jonasdemencia rolled the dice`);
     requestAnimationFrame(animate);
     rollButton.style.transform = '';
 });
 
 // Ajuste de redimensionamento
 window.addEventListener('resize', () => {
     camera.aspect = window.innerWidth / window.innerHeight;
     camera.updateProjectionMatrix();
     renderer.setSize(window.innerWidth, window.innerHeight);
     setInitialDicePosition(); // Adicionar esta linha
 });
 
 // Renderiza√ß√£o inicial
 renderer.render(scene, camera);
 console.log(`[2025-04-19 22:26:19] D4 initialized by user jonasdemencia`);
     </script>
 
 
 </body>
 </html>
